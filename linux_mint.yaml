# Prepares LinuxMint19 desktop.
# start from preparing ssh:
# sudo apt install openssh-server ntp;systemctl enable ssh && systemctl start ssh
#
- name: prepare_mint_desktop
  hosts: all
  vars:
    install_optional: true                    # should optional packages be installed?
    install_deb: true                         # should extra deb packages should be installed
    install_vscode_extensions: true           # should we install extra vscode extensions
    install_mitogen: false                    # false by default
    enable_bbr: true                          # enable TCP BBR congestion control
    modify_grub: false                        # don't touch grub settings, unless told to do so
    active_user: "{{ ansible_ssh_user }}"     # user for which you're setting folders. By default taken from group_vars
    codename: bionic                          # codename of version you're setting PPAs for
    retries_count: 4                          # how many retries
    delay_time: 15                            # delay time in seconds between retries
    bin_path: /usr/local/bin                  # Where to put all downloaded execs.
    reboot_required: false                    # force reboot even if apt upgrade won't change anything
  vars_files:
    - variables.yml
  become: true
  gather_facts: no
  pre_tasks:
    - name: verify_ansible_meets_version_requirements
      assert:
        that: "ansible_version.full is version_compare('2.7', '>=')"
        msg: >
          "You must update Ansible to at least 2.7 to use this version of playbook"
      tags:
      - assert
    - name: run_initial_setup_instead_of_gather_facts
      setup:
        gather_timeout: 30
      retries: "{{ retries_count }}"
      delay: "{{ delay_time }}"
      register: setup_status
      until: setup_status is success
      tags:
      - assert
    - name: assert_root_partition_is_5_GB_of_free_space
      assert: { that: item.mount != '/' or item.size_available > 5368709120 } # 5 GB free
      loop: '{{ ansible_mounts }}'
      ignore_errors: no
      register: freespace
      tags:
      - assert
  tasks:
  - name: start_timesyncd
    systemd:
      name: systemd-timesyncd
      state: started
      enabled: true
    changed_when: false
    tags:
    - base
  - name: start_timedatectl_set_ntp
    shell: timedatectl set-ntp on
    tags:
    - base
    changed_when: false
# Install apt pgp keys (files)
  - name: install_apt_keys
    apt_key:
      url: "{{ item }}"
      state: present
    loop: "{{ keys }}"
    register: keys
    retries: "{{ retries_count }}"
    delay: "{{ delay_time }}"
    until: keys is success
    any_errors_fatal: true
    tags:
    - keys
    - base
# Install apt gpg keys (ID)
  - name: install_apt_keys_by_id
    apt_key:
      keyserver: "{{ item.server}}"
      state: present
      id: "{{ item.key }}"
    loop: "{{ keys_pgp }}"
    register: keys_pgp
    retries: "{{ retries_count }}"
    delay: "{{ delay_time }}"
    until: keys_pgp is success
    any_errors_fatal: true
    tags:
    - keys
    - base
# remove obsolete repositories
  - name: remove_obsolete_repositories_from_variables_file
    apt_repository:
      repo: "{{ item.repo }}"
      state: absent
    loop: "{{ repositories_remove }}"
    retries: "{{ retries_count }}"
    delay: 3
    register: repositories_remove
    until: repositories_remove  is success
    any_errors_fatal: false
    tags:
    - repositories
    - base
# Add basic repositories
  - name: add_basic_repositories_from_variables_file
    apt_repository:
      repo: "{{ item.repo }}"
      state: present
      codename: "{{ codename }}"
      filename: "{{ item.filename }}"
    loop: "{{ repositories }}"
    retries: "{{ retries_count }}"
    delay: 3
    register: repositories
    until: repositories  is success
    any_errors_fatal: false
    tags:
    - repositories
    - base
# Add optional repositories
  - name: add_optional_repositories_from_variables_file
    apt_repository:
      repo: "{{ item.repo }}"
      state: present
      codename: "{{ item.codename }}"
      filename: "{{ item.filename }}"
    loop: "{{ repositories_optional }}"
    retries: "{{ retries_count }}"
    delay: "{{delay_time}}"
    register: repositories
    until: repositories  is success
    any_errors_fatal: false
    tags:
    - repositories
    - base
  - name: apt_initial_refresh
    apt:
      update_cache: yes
    ignore_errors: true
    changed_when: false
    tags:
    - packages
# Install essentials - packages needed for repos or other packages. Mostly OS-related
  - name: install_essential_packages
    apt:
      name: "{{ item }}"
      state: latest
      update_cache: no
    loop: "{{ packages_essential }}"
    retries: "{{ retries_count }}"
    delay: "{{delay_time}}"
    register: packages_essential
    until: packages_essential is success
    any_errors_fatal: false
    tags:
    - packages
    - base
# Install basic packages
  - name: install_packages
    apt:
      name: "{{ item }}"
      state: latest
      update_cache: no
    loop: "{{ packages }}"
    retries: "{{ retries_count }}"
    delay: "{{delay_time}}"
    register: packages
    until: packages is success
    any_errors_fatal: false
    tags:
    - packages
    - base
# Install optional packages - if variable `install_optional` is set to true
  - name: install_optional_packages
    apt:
      name: "{{ item }}"
      state: latest
      update_cache: no
    loop: "{{ packages_optional }}"
    retries: "{{ retries_count }}"
    delay: "{{delay_time}}"
    register: packages_optional
    until: packages_optional is success
    when: install_optional == true
    any_errors_fatal: false
    tags:
    - packages
    - optional
# Install 3-rd party software not available in repos
  - name: install_extra_deb_packages_from_variables_file
    apt:
      deb: "{{ item }}"
      state: present
      update_cache: no
      only_upgrade: yes
    loop: "{{ deb }}"
    retries: "{{ retries_count }}"
    delay: "{{delay_time}}"
    register: r_apt_deb
    until: r_apt_deb is success
    any_errors_fatal: false
    when: install_deb == true
    tags:
    - packages
# Install Python's pip packages
  - name: install_pip_packages
    pip:
      name: "{{ item }}"
      extra_args: --upgrade
    loop: "{{ pip }}"
    retries: "{{ retries_count }}"
    delay: "{{ delay_time }}"
    register: pip
    until: pip is success
    any_errors_fatal: true
    tags:
    - packages
    - base
    - python
    # Download 3-rd party software and unarchive it to `bin_path` setting +x
  - name: check_if_bin_path_exists
    file:
      path: "{{ bin_path }}"
      state: directory
    retries: "{{ retries_count }}"
    delay: "{{ delay_time }}"
    tags:
    - base
    - downloads
    - apps
  - name: download_and_unarchive
    unarchive:
      src: "{{ item.urls }}"
      dest: "{{ bin_path }}"
      keep_newer: true
      mode: +x
      remote_src: yes
      extra_opts: [-j]
    when: item.skip_tree == false
    loop: "{{ down }}"
    tags:
    - base
    - downloads
    - apps
# Need time to rework this
#  - block:
#    - name: check_if_mitogen_path_exists
#      file:
#        path: "{{ item.dest_path }}"
#        state: directory
#      retries: "{{ retries_count }}"
#      delay: "{{ delay_time }}"
#      loop: "{{ mitogen }}"
#    - name: download_and_unarchive_mitogen
#      unarchive:
#        src: "{{ item.urls }}"
#        dest: "{{ item.dest_path }}"
#        keep_newer: true
##        mode: +x
#        remote_src: yes
##        extra_opts: [-j]
#        extra_opts: [--strip-components=1]
#      loop: "{{ mitogen }}"
#    - name: replace_mitogen_values_in_ansible_config
#      lineinfile:
#        path: /etc/ansible/ansible.cfg.copy
#        #regexp: '^[defaults]'
#        insertafter: '(\[defaults\])'
#        firstmatch: yes
#        line: '\1 = STRATEGy=mitogen'
#        regexp: '(\[defaults\])'
#        backrefs: no
#        #state: present
#        #backrefs: yes
#
#    when: install_mitogen == true
#    tags:
#    - base
#    - downloads
#    - apps
#    - mitogen

# Download 3-rd party software and unarchive  it (flatten archive folder tree) to `bin_path` setting +x
  - name: download_unarchive_and_flatten
    unarchive:
      src: "{{ item.urls }}"
      dest: "{{ bin_path }}"
      keep_newer: true
      mode: +x
      remote_src: yes
      extra_opts: ['--strip-components={{ item.skip_levels|int }}']
      exclude:
       - LICENSE
       - README.md
    when: item.skip_tree == true
    loop: "{{ down }}"
    tags:
    - base
    - downloads
    - apps
# Download 3-rd party software to `bin_path` setting +x
  - name: download_files
    get_url:
      url: "{{ item.urls }}"
      dest: "{{ bin_path }}/{{ item.destination }}"
      mode: 0755
      force: yes
    loop: "{{ files }}"
    tags:
    - base
    - downloads
    - apps
# Start user-related modification block
  - name: user_mods_block
    block:
    - name: create_or_check_users_groups
      user:
        name: "{{ active_user }}"
        groups:
          - root
          - vboxusers
          - docker
          - adm
          - sudo
          - video
          - cdrom
          - plugdev
          - dialout
        state: present
        append: true
      any_errors_fatal: false
      register: active_user_account
      tags:
      - base
      - user
    - name: set_fact_for_users_home_dir
      set_fact:
        "active_user_homedir": "{{ active_user_account.home }}"
      tags:
      - base
      - user
    - name: make_sure_autostart_folder_exists
      file:
        path: "{{ active_user_homedir }}/.config/autostart"
        state: directory
        owner: "{{ active_user }}"
        group: "{{ active_user }}"
        mode: 0755
      register: create_autostart
      retries: "{{ retries_count }}"
      delay: "{{delay_time}}"
      until: create_autostart is success
      any_errors_fatal: true
      tags:
      - base
      - user
    - name: create_startup_applications
      copy:
        dest: "{{ active_user_homedir }}/.config/autostart/{{ item.filename }}"
        src: "{{ item.source }}"
        owner: "{{ active_user }}"
        group: "{{ active_user }}"
        force: false
      loop: "{{ startup }}"
      any_errors_fatal: false
      register: r_create_startup_applications
      retries: "{{ retries_count }}"
      delay: "{{delay_time}}"
      until: r_create_startup_applications is success
    tags:
    - base
    - user
  # start application mod block
  - name: install_vscode_extensions
    block:
      - shell: dpkg-query -s code | grep 'install ok installed'
        register: r_dpkg_query_vscode
        any_errors_fatal: false
        ignore_errors: true
        changed_when: "r_dpkg_query_vscode.stdout != 'Status: install ok installed'"
      - shell: if [ ! $(code --list-extensions|grep {{ item }}) ]; then code --install-extension {{ item }}; fi
        loop: "{{ vscode }}"
        register: r_install_extension
        retries: "{{ retries_count }}"
        delay: "{{ delay_time }}"
        until: r_install_extension is success
        become: "{{ active_user }}"
        changed_when: "r_install_extension.stdout  != ''"
        when: r_dpkg_query_vscode.rc == 0
        any_errors_fatal: false
        ignore_errors: true
    tags:
    - optional
    - user
    - vscode
    when: install_vscode_extensions == true
  # Start OS related block
  - name: start_os_tweaks
    block:
    # OS related tweaks and finetuning
    - name: set_timezone
      timezone:
        name: "{{ timezone }}"
      any_errors_fatal: false
    - name: add_neofetch_to_bashrc_globals
      lineinfile:
        path: /etc/bash.bashrc
        line: neofetch
      any_errors_fatal: false
    - name: set_avahi_config
      lineinfile:
        dest: /etc/avahi/avahi-daemon.conf
        regexp: 'domain-name=local'
        line: 'domain-name=alocal'
        backrefs: yes
      any_errors_fatal: false
      register: r_set_avahi_config
    - name: nsswitch_config
      lineinfile:
        dest: /etc/nsswitch.conf
        regexp: '^hosts:'
        line: 'hosts:          files dns'
        backrefs: yes
      any_errors_fatal: false
    - name: restar_avahi_after_changes
      systemd:
        name: avahi-daemon
        state: restarted
        enabled: true
      when: r_set_avahi_config is changed
    - name: set_grub_defaults_for_SSD
      lineinfile:
        dest: /etc/default/grub
        regexp: '^GRUB_CMDLINE_LINUX_DEFAULT='
        line: 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash elevator=deadline"'
        backrefs: true
      any_errors_fatal: false
      register: grub_default
      when: modify_grub == true
    - name: grub_update
      shell: update-grub2
      when: grub_default.changed and modify_grub == true
    - name: enable_timeshift_in_rsync_mode
      shell: timeshift --rsync --yes
      args:
        creates: /etc/timeshift.json
      any_errors_fatal: false
    - name: add_user_to_sudoers
      copy:
        dest: "/etc/sudoers.d/{{ active_user }}"
        owner: root
        group: root
        mode: 0444
        content: |
          {{ active_user }} ALL=(ALL) NOPASSWD: ALL
      any_errors_fatal: false
      retries: "{{ retries_count }}"
    - name: create_fstrim_folder_for_systemd_override
      file:
        path: /etc/systemd/system/fstrim.timer.d
        state: directory
    - name: create_fstrim_override_for_systemd
      copy:
        dest: /etc/systemd/system/fstrim.timer.d/override.conf
        content: |
          [Timer]
          OnCalendar=hourly
      register: r_create_fstrim_override
    - name: start_fstrim.timer
      systemd:
        daemon_reload: true
        name: fstrim.timer
        state: restarted
        enabled: true
      when: r_create_fstrim_override is changed
    - name: sysctl_change_qdisc
      sysctl:
        name: net.core.default_qdisc
        value: fq
        state: present
        reload: no
      when: enable_bbr == true
    - name: sysctl_change_congestion_control
      sysctl:
        name: net.ipv4.tcp_congestion_control
        value: bbr
        state: present
        reload: yes
      when: enable_bbr == true
    - name: sysctl_change_vm_swappines
      sysctl:
        name: vm.swappiness
        value: "{{ 1|int }}"
        state: present
        reload: yes
    - name: change_alternatives
      alternatives:
        name: "{{ item.name }}"
        path: "{{ item.path }}"
      loop: "{{ alternatives }}"
      register: r_alternatives
      retries: "{{ retries_count }}"
      delay: "{{ delay_time }}"
      until: r_alternatives is success
    - name: update_and_reboot
      apt:
        upgrade: "yes"
        update_cache: yes
        autoclean: yes
      register: apt_upgrade
      retries: "{{ retries_count }}"
      delay: "{{ delay_time }}"
      until: apt_upgrade is success
    # Reboot
    - name: reboot_after_changes
      reboot:
        pre_reboot_delay: 60
      when: (reboot_required is defined and reboot_required == true) or (apt_upgrade.changed)
      register: r_reboot_after_upgrade
      any_errors_fatal: false
    - name: wait_for_server_to_finish_rebooting_ssh
      wait_for:
        host: '{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}'
        state: started
        delay: 60
        port: 22
        timeout: 1200
      connection: local
      register: r_wait_for_ssh
      retries: "{{ retries_count }}"
      delay: "{{delay_time}}"
      ignore_errors: true
      until: r_wait_for_ssh is success
      when: (r_reboot_after_upgrade is defined and r_reboot_after_upgrade.changed) or (reboot_required == true)
    - name: clean_apt_cache
      shell: apt clean all -y
      any_errors_fatal: false
      register: r_clean_apt_cache
      retries: "{{ retries_count }}"
      delay: "{{delay_time}}"
      changed_when: false
    tags:
    - base
    - user
    - os